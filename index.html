<!DOCTYPE html>
<html lang="en" class="no-js">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Sargasso Designs</title>
    <meta name="description" content="A full service frontend design studio." />
    <meta
      name="keywords"
      content="sargasso design, front end design, web design, front end development, web development"
    />
    <link rel="shortcut icon" href="favicon.ico" />
    <link
      href="https://fonts.googleapis.com/css?family=Be+Vietnam:500&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="css/base.css" />
  </head>

  <body class="background-image">
    <main>
      <div class="frame"></div>
    </main>
  </body>

  <script type="text/javascript" src="js/bundle.js"></script>
  <script type="module">
    let imgSize = [1600, 1200]

    const vertex = `
      attribute vec2 uv;
      attribute vec2 position;
      varying vec2 vUv;
      void main() {
          vUv = uv;
          gl_Position = vec4(position, 0, 1);
      }
    `

    const fragment = `
      precision highp float;
      precision highp int;
      uniform sampler2D tWater;
      uniform sampler2D tFlow;
      uniform float uTime;
      varying vec2 vUv;
      uniform vec2 uMouse;
      uniform vec4 res;

      void main() {
        vec3 flow = texture2D(tFlow, vUv).rgb;

        vec2 uv = .5 * gl_FragCoord.xy / res.xy ;

        vec2 myUV = (uv - vec2(0.5))*res.zw + vec2(0.5);

        // myUV -= flow.xy * (0.15 * 0.5);
        myUV -= flow.xy * (2.5 * .2);

        vec3 tex = texture2D(tWater, myUV).rgb;

        gl_FragColor.rgb = vec3(tex.r, tex.g, tex.b);
        // gl_FragColor.rgb = vec3(
        //   tex.r - 0.25 * abs(0.5 - (uMouse.x)),
        //   tex.g - 0.25 * abs(0.5 - (uMouse.y)),
        //   tex.b
        // );
        // gl_FragColor.rgb = vec3(
        //   0.8 * tex.r - 0.1 * sin(0.1 * sin(uTime) + 1.0) * 0.5,
        //   // tex.g - 0.15 * sin(sin(uTime) + 1.0) * 0.5,
        //   // tex.b - 0.15 * sin(sin(0.35 * uTime) + 1.0) * 0.5
        //   tex.g,
        //   tex.b
        // );
        // gl_FragColor.rgb = vec3(
        //   // 0.75 * tex.r + 0.25 * abs(0.5 - (uMouse.x)),
        //   tex.r - 0.3 + 0.4 * abs(0.5 - (uMouse.x)),
        //   tex.g,
        //   tex.b
        // );
        gl_FragColor.rgb = vec3(
          tex.r,
          tex.g,
          tex.b
        );

        // gl_FragColor.a = 0.9;
        gl_FragColor.a = tex.r;
      }
    `
    {
      const renderer = new ogl.Renderer({
        dpr: 2,
        alpha: true,
        premultipliedAlpha: true,
      })
      const gl = renderer.gl
      document.body.appendChild(gl.canvas)

      const isTouchCapable = 'ontouchstart' in window

      let aspect = 1
      const mouse = new ogl.Vec2(-1)
      const absoluteMouse = new ogl.Vec2(0)
      const velocity = new ogl.Vec2()
      function resize() {
        let a1, a2
        var imageAspect = imgSize[1] / imgSize[0]
        if (window.innerHeight / window.innerWidth < imageAspect) {
          a1 = 1
          a2 = window.innerHeight / window.innerWidth / imageAspect
        } else {
          a1 = (window.innerWidth / window.innerHeight) * imageAspect
          a2 = 1
        }
        mesh.program.uniforms.res.value = new ogl.Vec4(
          window.innerWidth,
          window.innerHeight,
          a1,
          a2
        )

        renderer.setSize(window.innerWidth, window.innerHeight)
        aspect = window.innerWidth / window.innerHeight
      }
      const flowmap = new ogl.Flowmap(gl, { falloff: 0.2, dissipation: 0.9 })
      const geometry = new ogl.Geometry(gl, {
        position: {
          size: 2,
          data: new Float32Array([-1, -1, 3, -1, -1, 3]),
        },
        uv: { size: 2, data: new Float32Array([0, 0, 2, 0, 0, 2]) },
      })
      const texture = new ogl.Texture(gl, {
        minFilter: gl.LINEAR,
        magFilter: gl.LINEAR,
        premultiplyAlpha: true,
      })
      const img = new Image()
      img.onload = () => (texture.image = img)
      img.crossOrigin = 'Anonymous'

      if (isTouchCapable) {
        img.src = 'img/sargasso-design.svg'
        imgSize = [800, 1000]
      } else {
        img.src = 'img/sargasso-design.svg'
      }

      let a1, a2
      var imageAspect = imgSize[1] / imgSize[0]
      if (window.innerHeight / window.innerWidth < imageAspect) {
        a1 = 1
        a2 = window.innerHeight / window.innerWidth / imageAspect
      } else {
        a1 = (window.innerWidth / window.innerHeight) * imageAspect
        a2 = 1
      }

      const program = new ogl.Program(gl, {
        vertex,
        fragment,
        uniforms: {
          uTime: { value: 0 },
          tWater: { value: texture },
          res: {
            value: new ogl.Vec4(window.innerWidth, window.innerHeight, a1, a2),
          },
          img: { value: new ogl.Vec2(imgSize[0], imgSize[1]) },
          tFlow: flowmap.uniform,
          uMouse: {
            value: new ogl.Vec2(absoluteMouse[0], absoluteMouse[1]),
          },
        },
      })
      const mesh = new ogl.Mesh(gl, { geometry, program })

      window.addEventListener('resize', resize, false)
      resize()

      if (isTouchCapable) {
        window.addEventListener('touchstart', updateMouse, false)
        window.addEventListener('touchmove', updateMouse, { passive: false })
      } else {
        window.addEventListener('mousemove', updateMouse, false)
      }
      let lastTime
      const lastMouse = new ogl.Vec2()
      function updateMouse(e) {
        e.preventDefault()
        if (e.changedTouches && e.changedTouches.length) {
          e.x = e.changedTouches[0].pageX
          e.y = e.changedTouches[0].pageY
        }
        if (e.x === undefined) {
          e.x = e.pageX
          e.y = e.pageY
        }
        mouse.set(e.x / gl.renderer.width, 1.0 - e.y / gl.renderer.height)
        absoluteMouse.set(
          e.x / gl.renderer.width,
          1.0 - e.y / gl.renderer.height
        )
        if (!lastTime) {
          lastTime = performance.now()
          lastMouse.set(e.x, e.y)
        }

        const deltaX = e.x - lastMouse.x
        const deltaY = e.y - lastMouse.y

        lastMouse.set(e.x, e.y)

        let time = performance.now()

        let delta = Math.max(10.4, time - lastTime)
        lastTime = time
        velocity.x = deltaX / delta
        velocity.y = deltaY / delta
        velocity.needsUpdate = true
      }
      requestAnimationFrame(update)
      function update(t) {
        requestAnimationFrame(update)
        if (!velocity.needsUpdate) {
          mouse.set(-1)
          velocity.set(0)
        }
        velocity.needsUpdate = false
        flowmap.aspect = aspect
        flowmap.mouse.copy(mouse)
        flowmap.velocity.lerp(velocity, velocity.len ? 0.15 : 0.1)
        flowmap.update()
        program.uniforms.uTime.value = t * 0.01
        program.uniforms.uMouse.value = absoluteMouse
        renderer.render({ scene: mesh })
      }
    }
  </script>
</html>
